import {
  require_built
} from "./chunk-HLV2FEDH.js";
import {
  require_events
} from "./chunk-MRJJSJK3.js";
import {
  __commonJS
} from "./chunk-7FP5O474.js";

// node_modules/@keyv/redis/src/index.js
var require_src = __commonJS({
  "node_modules/@keyv/redis/src/index.js"(exports, module) {
    var EventEmitter = require_events();
    var Redis = require_built();
    var KeyvRedis = class extends EventEmitter {
      constructor(uri, options) {
        super();
        this.ttlSupport = true;
        this.opts = {};
        this.opts.dialect = "redis";
        if (uri.options && uri.options.family || uri.options && uri.isCluster) {
          this.redis = uri;
        } else {
          options = { ...typeof uri === "string" ? { uri } : uri, ...options };
          this.redis = new Redis(options.uri, options);
        }
        this.redis.on("error", (error) => this.emit("error", error));
      }
      _getNamespace() {
        return `namespace:${this.namespace}`;
      }
      get(key) {
        return this.redis.get(key).then((value) => {
          if (value === null) {
            return void 0;
          }
          return value;
        });
      }
      getMany(keys) {
        return this.redis.mget(keys).then((rows) => rows);
      }
      set(key, value, ttl) {
        if (typeof value === "undefined") {
          return Promise.resolve(void 0);
        }
        return Promise.resolve().then(() => {
          if (typeof ttl === "number") {
            return this.redis.set(key, value, "PX", ttl);
          }
          return this.redis.set(key, value);
        }).then(() => this.redis.sadd(this._getNamespace(), key)).then(() => void 0);
      }
      delete(key) {
        return this.redis.del(key).then((items) => this.redis.srem(this._getNamespace(), key).then(() => items > 0));
      }
      deleteMany(key) {
        return this.delete(key);
      }
      clear() {
        return this.redis.smembers(this._getNamespace()).then((keys) => this.redis.del([...keys, this._getNamespace()])).then(() => void 0);
      }
      async *iterator(namespace) {
        const scan = this.redis.scan.bind(this.redis);
        const get = this.redis.mget.bind(this.redis);
        async function* iterate(curs, pattern) {
          const [cursor, keys] = await scan(curs, "MATCH", pattern);
          if (keys.length > 0) {
            const values = await get(keys);
            for (const [i] of keys.entries()) {
              const key = keys[i];
              const value = values[i];
              yield [key, value];
            }
          }
          if (cursor !== "0") {
            yield* iterate(cursor, pattern);
          }
        }
        yield* iterate(0, `${namespace}:*`);
      }
      has(key) {
        return this.redis.exists(key).then((value) => value !== 0);
      }
      disconnect() {
        return this.redis.disconnect();
      }
    };
    module.exports = KeyvRedis;
  }
});
export default require_src();
//# sourceMappingURL=@keyv_redis.js.map
